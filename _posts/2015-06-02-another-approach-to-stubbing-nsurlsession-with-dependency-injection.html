---
layout: post
title: Another Approach To Stubbing NSURLSession With Dependency Injection
date: 2015-06-02 20:13:20.000000000 +02:00
type: post
published: true
status: publish
categories:
- TDD
tags:
- Mocking
- NSURLSession
- Stubbing
- Testing
meta:
  keywords: NSURLSession, testing, stubbing, mocking
  robotsmeta: index,follow
  title: Another Approach To Stubbing NSURLSession With Dependency Injection
  description: A clever and easy way to stub NSURLSessions.
  _edit_last: '1'
  _wpcom_is_markdown: '1'
author:
  login: dom
  email: dominik.hauser@dasdom.de
  display_name: dom
  first_name: ''
  last_name: ''
---
<p>Recently I watched a video by <a href="https://www.youtube.com/watch?v=Jzlz3Bx-NzM">Jon Reid</a>. Jon Reid explains how he uses unit tests to test networking code. This video was an eye opener for me. If you haven't watched it yet, do it now.</p>
<p>Here is how his approach looks like in Swift using  <span class="lang:swift decode:true  crayon-inline ">NSURLSession</span>:</p>
<p>First we need a property to inject the mock url session in the test:</p>
<pre class="lang:swift decode:true ">
public class Foo {

  public var session: URLSession = NSURLSession.sharedSession()

}
</pre>
<p>Note the type of  <span class="lang:swift decode:true  crayon-inline ">session</span> . It is of type  <span class="lang:swift decode:true  crayon-inline ">URLSession</span>.  <span class="lang:swift decode:true  crayon-inline ">URLSession</span>  is a protocol which declares one method:</p>
<pre class="lang:swift decode:true ">
public protocol URLSession {
  func dataTaskWithURL(url: NSURL, completionHandler: ((NSData!, NSURLResponse!, NSError!) -> Void)?) -> NSURLSessionDataTask
}
</pre>
<p>To make the compiler happy with the above definition we need to tell it that  <span class="lang:swift decode:true  crayon-inline ">NSURLSession</span>  implements the  <span class="lang:swift decode:true  crayon-inline ">URLSession</span>  protocol:</p>
<pre class="lang:swift decode:true ">
extension NSURLSession: URLSession {
}
</pre>
<p>The networking code in this example is quite easy. It just fetches a user profile from <a href="https://app.net">App.net</a>:</p>
<pre class="lang:swift decode:true ">
let urlString = "https://api.app.net/users/@(username)"
let task = session.dataTaskWithURL(NSURL(string: urlString)!, completionHandler: { (data, response, error) -> Void in
      
  let rawDictionary = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil) as! [String:AnyObject]
  self.user = self.userFromDictionay(rawDictionary)
      
})
task.resume()
</pre>
<p>The method  <span class="lang:swift decode:true  crayon-inline ">userFromDictionay(_:)</span> extracts and unwraps the elements which are needed to create a user and returns a user or nil if not all elements could be extracted:</p>
<pre class="lang:swift decode:true ">func userFromDictionay(dictionary: [String:AnyObject]) -&gt; User? {
  if let rawUser = dictionary["data"] as? [String:AnyObject],
    username = rawUser["username"] as? String,
    name = rawUser["name"] as? String,
    counts = rawUser["counts"] as? [String:Int],
    followers = counts["followers"],
    following = counts["following"],
    posts = counts["posts"] {
        
      return User(username: username, name: name, numberOfPosts: posts, followers: followers, following: following)
  }
  return nil
}
</pre>
<p>To store the user, we also need a user property:</p>
<pre class="lang:swift decode:true ">
  public var user: User?
</pre>
<p>The user looks like this:</p>
<pre class="lang:swift decode:true ">
import Foundation

public struct User {
  public let username: String
  public let name: String
  public let numberOfPosts: Int
  public let followers: Int
  public let following: Int
  
  public init(username: String, name: String, numberOfPosts: Int, followers: Int, following: Int) {
    self.username = username
    self.name = name
    self.numberOfPosts = numberOfPosts
    self.followers = followers
    self.following = following
  }
}
</pre>
<p>The initializer is needed because we need to initialize a user in the tests and it seems that the generated initializer is declared as <code>internal</code>.</p>
<p>That's all for the networking code.</p>
<p>Let's switch to the test code. The mock url session looks like this:</p>
<pre class="lang:swift decode:true ">
class MockURLSession: URLSession {
    
  typealias Handler = (NSData!, NSURLResponse!, NSError!) -> Void
  var completionHandler: Handler?
  var url: NSURL?
    
  func dataTaskWithURL(url: NSURL, completionHandler: ((NSData!, NSURLResponse!, NSError!) -> Void)?) -> NSURLSessionDataTask {
    self.url = url
    self.completionHandler = completionHandler
    return NSURLSessionDataTask()
  }
}
</pre>
<p>Note that the mock url session stores the completion handler in a property.</p>
<p>The test looks like this:</p>
<pre class="lang:swift decode:true ">func testFetchingOfUserSetUserProperty() {
  // Arrange
  let mockURLSession = MockURLSession()
  secondViewController.session = mockURLSession
  
  // Act
  secondViewController.fetchUserWithUsername("dasdom")
  let userDictionary = ["data": ["username": "dasdom", "name": "Dominik", "counts": ["followers": 11, "following": 22, "posts": 33]]] as NSDictionary
  let data = NSJSONSerialization.dataWithJSONObject(userDictionary, options: nil, error: nil)
  mockURLSession.completionHandler!(data!, nil, nil)
  
  // Assert
  let testUser = User(username: "dasdom", name: "Dominik", numberOfPosts: 33, followers: 11, following: 22)
  XCTAssertTrue(secondViewController.user! == testUser, "should be equal")
}
</pre>
<p>First we inject the mock url session. Then we fetch a user and call the caught completionHandler with a test JSON. Finally we assert that the fetched user is as we expected.</p>
<p>To make this work we also need to override the  <span class="lang:swift decode:true  crayon-inline ">==</span> operator:</p>
<pre class="lang:swift decode:true ">public func ==(left: User, right: User) -&gt; Bool {
  if left.username != right.username {
    return false
  }
  if left.name != right.name {
    return false
  }
  if left.numberOfPosts != right.numberOfPosts {
    return false
  }
  if left.followers != right.followers {
    return false
  }
  if left.following != right.following {
    return false
  }
  return true
}
</pre>
<p>Keep in mind that the response of a  <span class="lang:swift decode:true  crayon-inline ">NSURLDataTask</span> is delivered on a background thread. So you can't use this approach to check if a label got updated as a result of the response. But in this case you would test two things at the same time. You shouldn't do this anyway.</p>
<p>If you have any comments or questions about this, ping be on App.net or Twitter.</p>

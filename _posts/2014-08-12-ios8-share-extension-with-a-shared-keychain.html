---
layout: post
title: iOS 8 Share Extension With A Shared Keychain
date: 2014-08-12 15:59:19.000000000 +02:00
type: post
published: true
status: publish
categories:
- General
tags:
- extensions
- iOS8
- keychain
meta:
  _edit_last: '1'
  _flattr_post_hidden: '0'
  _flattr_post_customurl: ''
  _yoast_wpseo_linkdex: '78'
  _yoast_wpseo_focuskw: share extension
  _yoast_wpseo_metadesc: How to use the keychain with an iOS 8 share extension.
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1437193772;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:395;}i:1;a:1:{s:2:"id";i:563;}i:2;a:1:{s:2:"id";i:100;}}}}
author:
  login: dom
  email: dominik.hauser@dasdom.de
  display_name: dom
  first_name: ''
  last_name: ''
---
<p>Extensions are one of the coolest new features in iOS8. Nearly every iOS developer (and user) has waited for this for a long time. Finally very [convenient scenarios](http://oleb.net/blog/2014/06/the-power-of-ios8/) come true. In fact [AgileBits](http://agilebits.com/) (creator of 1Password) has already [published](https://github.com/AgileBits/onepassword-app-extension) a class to integrate 1Password extension support into every App. This is really cool.</p>
<p>Now let's say we want to build a share extension for a social networking App. To post to the social network the user has to be logged in (usually this means the user needs a valid access token). We don't want to force the user to log into the network twice. We want to share the access token between the App and the extension. How can we do this?</p>
<p>One possibility is to use a shared user defaults. But in this case the access token would be stored unencrypted on the device. This is not a good idea.</p>
<p>What we need is to store the access token in the keychain of iOS and access this keychain from the App and the extension. Let's do exactly this. (The demo project is on [github](https://github.com/dasdom/KeychainDemo).)</p>
<p>> As far as I understand it, I'm not allowed to show screenshots from Xcode 6 and iOS8 because those are still under NDA. I will update this post with screenshots when the NDA is lifted.</p>
<p>Open Xcode6 and create a new project. Select the Single View Application template. Chose a name, select the language Swift and select iPhone as the target device.</p>
<p>We need to access the keychain in the App and in the extension. Therefore the code to do that needs to be accessible from both targets. This is the perfect use case for a framework.<br />
In the project navigator select the project. Add a new target to the project and make it framework. Chose the name KeychainAccess. Let the 'Project' and the 'Embed in Application' as it is.</p>
<p>In the project navigator navigate to the folder KeychainAccess. Add a file to this folder. Select an iOS-Swift file and name it KeychainAccess.swift. Replace the content of the file with this:</p>
<pre class="lang:swift decode:true ">import Foundation

public class DDHKeychain {
    
    private class func secClassGenericPassword() -&gt; String {
        return NSString(format: kSecClassGenericPassword)
    }
    
    private class func secClass() -&gt; String {
        return NSString(format: kSecClass)
    }
    
    private class func secAttrService() -&gt; String {
        return NSString(format: kSecAttrService)
    }
    
    private class func secAttrAccount() -&gt; String {
        return NSString(format: kSecAttrAccount)
    }
    
    private class func secValueData() -&gt; String {
        return NSString(format: kSecValueData)
    }
    
    private class func secReturnData() -&gt; String {
        return NSString(format: kSecReturnData)
    }

    
    public class func setPassword(password: String, account: String, service: String = "kDDHDefaultService") {
        var secret: NSData = password.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
        let objects: Array = [secClassGenericPassword(), service, account, secret]
        
        let keys: Array = [secClass(), secAttrService(), secAttrAccount(), secValueData()]
        
        let query = NSDictionary(objects: objects, forKeys: keys)
        
        SecItemDelete(query as CFDictionaryRef)
        
        let status = SecItemAdd(query as CFDictionaryRef, nil)
    }
    
    public class func passwordForAccount(account: String, service: String = "kDDHDefaultService") -&gt; String {
        
        let queryAttributes = NSDictionary(objects: [secClassGenericPassword(), service, account, true], forKeys: [secClass(), secAttrService(), secAttrAccount(), secReturnData()])
        
        
        var dataTypeRef : Unmanaged&lt;AnyObject&gt;?
        let status = SecItemCopyMatching(queryAttributes, &amp;dataTypeRef);
        
        let retrievedData : NSData = dataTypeRef!.takeRetainedValue() as NSData
        
        let password = NSString(data: retrievedData, encoding: NSUTF8StringEncoding)
        
        return password as String
    }
    
}</pre>
<p>This is basic keychain access. Please don't use this in production code. This is just for demo purposes. (As a bare minimum this class needed some error handling. But for the demo this is just enough.)</p>
<p>To add an extension to the project, add another target. Make it a share extension and call it `LinkShare`. Again 'Project' should be your project and 'Embed in Application' should be your application. If Xcode asks you whether it should activate a "LinkShare" scheme, select Activate.</p>
<p>To share a keychain between the application and it's embedded extension both have to have keychain sharing activated.<br />
Select your App target and open the 'Capabilities' tab. Activate Keychain Sharing. Now select the LinkShare target and activate Keychain Sharing as well. In the LinkShare target add a keychain group and give it the same identifier as the keychain group in the main target. Delete the other keychain group. Now both targets share the same keychain.</p>
<p>In the LinkShare target in the 'General' tab link against the KeychainAccess.framework.</p>
<p>Now open the 'Info' tab of the LinkShare target and navigate to<br />
 <span class="theme:github lang:swift decode:true  crayon-inline ">NSExtension &gt; NSExtensionAttributes &gt; NSExtensionActivationRule </span><br />
. Change the  <span class="theme:github lang:swift decode:true  crayon-inline ">NSExtensionActivationSupportsWebURLWithMaxCount</span> to 1.</p>
<p>In this demo we want to type a "password" in the application and we want to read it in the extension. (In a real application we would log into an API and receive an access token. This would then be stored in the shared keychain and accessed from both, the application and the extension.)</p>
<p>Open the main storyboard of the application target and ad a textfield. Add constraints. Make the View Controller the delegate of the textfield. Replace the code in `ViewController.swift` with:</p>
<pre class="theme:github lang:swift decode:true ">import UIKit
import KeychainAccess

class ViewController: UIViewController, UITextFieldDelegate {
    
    func textFieldShouldReturn(textField: UITextField!) -> Bool {
        KeychainAccess.setPassword(textField.text, account: "SharedAccount")
        textField.resignFirstResponder()
        return false
    }
    
}</pre>
<p>In the folder of the share extension open the file `ShareViewController.swift`. Import the KeychainAccess module ( <span class="theme:github lang:swift decode:true  crayon-inline ">import KeychainAccess</span> ) and add the function:</p>
<pre class="theme:github lang:swift decode:true ">override func viewDidAppear(animated: Bool) {
        super.viewDidAppear(animated)
        
        let password = KeychainAccess.passwordForAccount("SharedAccount")
        textView.text = password
    }</pre>
<p>Now, build and run with the application scheme. Enter a password in the textfield. Then open a website in Safari and select the share button. In the popup select more and activate the LinkShare extension. Select the LinkShare extension.</p>
<p>You should now see the password you have entered in the textfield of the application.</p>
<p>It's magic, isn't it? </p>
<p>**Update:** Updated for Xcode 6.1 and Swift 1.1.</p>

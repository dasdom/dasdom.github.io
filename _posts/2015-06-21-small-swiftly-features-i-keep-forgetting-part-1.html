---
layout: post
title: Small Swiftly Features I Keep Forgetting - Part 1
date: 2015-06-21 15:16:16.000000000 +02:00
type: post
published: true
status: publish
categories:
- General
- Tips
tags:
- Snippets
- Swift 2.0
meta:
  description: Thinks I stubbled across while rereading the Swift ebook from Apple.
  robotsmeta: index,follow
  title: Small Swiftly Features I Keep Forgetting - Part 1
  _edit_last: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1437248166;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:541;}i:1;a:1:{s:2:"id";i:326;}i:2;a:1:{s:2:"id";i:447;}}}}
author:
  login: dom
  email: dominik.hauser@dasdom.de
  display_name: dom
  first_name: ''
  last_name: ''
---
<p>I'm reading the Apple Swift book once again. This time the prerelease version for Swift 2.0 and I rediscover things from earlier releases of Swift I had forgotten. So, ignore this post. This is just a reference for the future me. :)</p>
<p>## Swift Tour<br />
Functions can take a variable number of arguments.</p>
<pre class="lang:swift decode:true ">func sumOf(numbers: Int...) -&gt; Int {
  return numbers.reduce(0, combine: +)
}
sumOf(1,2,3)</pre>
<p>You can provide an explicit name in parentheses after set in a setter.</p>
<pre class="lang:swift decode:true ">struct Person {
  var name: String {
    get { return self.name }
    set(theNewName) { print("the new name is (theNewName)") }
  }
}
var person = Person()
person.name = "Dominik"</pre>
<p>## The Basics<br />
You can access the minimun and maximum values of each integer type with.</p>
<pre class="lang:swift decode:true ">let minValue = UInt8.min
let maxValue = UInt8.max</pre>
<p>## Strings and Characters<br />
Find out whether a `String` value is empty by checking its Boolean `isEmpty` property.</p>
<pre class="lang:swift decode:true ">let emptyString = ""
if emptyString.isEmpty {
  print("It's really empty")
}
</pre>
<p>## Collection Types<br />
Append an array of one or more compatible items with the addition assignement operator (`+=`).</p>
<pre class="lang:swift decode:true ">var shoppingList = ["Soy Milk", "Bread"]
shoppingList += ["Apples", "Bananas", "Coffee", "Creme"]</pre>
<p>You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing.</p>
<pre class="lang:swift decode:true ">shoppingList[4...5] = ["Bananas", "Bananas", "More Bananas"]
shoppingList</pre>
<p>If you need the integer index of each item as well as its value, use the `enumerate()` method to interate over the array instead.</p>
<pre class="lang:swift decode:true ">for (index, value) in shoppingList.enumerate() {
  print("(index): (value)")
}</pre>
<p>You can also initialize a set with an array literal, as shorthand way to write one or more values as a set collection.</p>
<pre class="lang:swift decode:true ">var favoriteGenres: Set = ["Rock", "Indie", "Sing and Songwriter"]</pre>
<p>Set: <span class="lang:swift decode:true  crayon-inline ">intersect(_:)</span>, <span class="lang:swift decode:true  crayon-inline ">intersect(_:)</span>, <span class="lang:swift decode:true  crayon-inline ">union(_:)</span> and  <span class="lang:swift decode:true  crayon-inline ">subtract(_:)</span> .</p>
<pre class="lang:swift decode:true ">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
oddDigits.union(evenDigits).sort()
oddDigits.intersect(evenDigits).sort()
oddDigits.subtract(singleDigitPrimeNumbers).sort()
oddDigits.exclusiveOr(singleDigitPrimeNumbers).sort()</pre>
<p>Did you find something one should mention here? Let me know.</p>

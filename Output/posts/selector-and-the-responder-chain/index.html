<!DOCTYPE html><html><head><meta charset="UTF-8"/><meta name="og:site_name" content="dasdom"/><link rel="canonical" href="https://dasdom.dev/posts/selector-and-the-responder-chain"/><meta name="twitter:url" content="https://dasdom.dev/posts/selector-and-the-responder-chain"/><meta name="og:url" content="https://dasdom.dev/posts/selector-and-the-responder-chain"/><title>#selector And The Responder Chain | dasdom</title><meta name="twitter:title" content="#selector And The Responder Chain | dasdom"/><meta name="og:title" content="#selector And The Responder Chain | dasdom"/><meta name="description" content="Here is how to use #selector in combination with the responder chain."/><meta name="twitter:description" content="Here is how to use #selector in combination with the responder chain."/><meta name="og:description" content="Here is how to use #selector in combination with the responder chain."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to dasdom"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">dasdom</a><nav><ul><li><a class="selected" href="/posts">Posts</a></li><li><a href="/books">Books</a></li><li><a href="/about">About</a></li><li><a href="/imprint">Imprint</a></li><li><a href="/privacy">Privacy</a></li></ul></nav></div></header><div class="wrapper"><p>3. Aug 2021</p><article><div class="content"><h1>#selector And The Responder Chain</h1><p>I don’t know about you, but I tend to forget that there is a responder chain in iOS. This post is to remind myself (and you) that the responder chain exists and that we can use it to react to button events.</p><h2>The Responder Chain</h2><p>In iOS, events (for example touch events) are delivered using the responder chain. The responder chain consists of responder objects. If you have a look at the documentation, you may have noticed that UIView and UIViewController are responder objects. This means they inherit from UIResponder:</p><img src="../../assets/2021-08-03/uiview_doc.png" width="400"/><p>When the user taps a view in the view hierarchy, iOS uses hit testing to figure out which responder object should get the touch event first. The process starts at the lowest level, the window. Then is propagates up the view hierarchy and checks for each view if the touch happened within its bounds. The last view in that process that got hit, receives the touch event first. If that view does not respond to the touch event, the event is passed to the next responder in the responder chain. When a view tells iOS that it did not get hit, the subviews of that view aren’t checked.</p><p>This has an interesting consequence. When a button is outside of the bounds of its superview but visible because clipsToBounds of the superview is set to false, it does not receive any touch events. So, when ever a button doesn’t work, remember to check if it is in the bound of its superview.</p><h2>Target-Action</h2><p>The target-action mechanism can be set up that is also uses the responder chain by setting the target to nil. Then iOS asks the first responder if it handles the action. If not the first responder passes the action to the <a href="https://developer.apple.com/documentation/uikit/uiresponder/1621099-next">next</a> responder.</p><p>Since Swift 2.2 you set up the action of a button using <code>#selector()</code>. The compiler checks if the method within the parentheses is implemented. But when using the responder chain, you can't tell if some class in the chain implements this method.</p><p>Here is how you can use <code>#selector()</code> and still send the events to the responder chain.</p><p>First we need a protocol for the method that should be executed.</p><pre><code><span class="keyword">@objc protocol</span> DetailShowable {
  <span class="keyword">@objc func</span> showDetail()
}
</code></pre><p>Then we can add an extension to <code>Selector</code> as described in <a href="https://medium.com/swift-programming/swift-selector-syntax-sugar-81c8a8b10df3#.6gteb7p1s">this awesome post</a> by <a href="https://twitter.com/AndyyHope">Andyy Hope</a> that looks like this:</p><pre><code><span class="keyword">private extension</span> <span class="type">Selector</span> {
  <span class="keyword">static let</span> showDetail = <span class="keyword">#selector</span>(<span class="type">DetailShowable</span>.<span class="property">showDetail</span>)
}
</code></pre><p>Adding the action to the responder chain is then as easy as this:</p><pre><code>button.<span class="call">addTarget</span>(<span class="keyword">nil</span>,
                 action: .<span class="dotAccess">showDetail</span>,
                 for: .<span class="dotAccess">touchUpInside</span>)
</code></pre><p>Then some responder object in the responder chain needs to conform to the <code>DetailShowable</code> protocol.</p><p>You can find the code on <a href="https://github.com/dasdom/SelectorSyntaxSugar">Github</a>.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/responder-chain">Responder Chain</a></li><li><a href="/tags/selector">Selector</a></li></ul></article></div><footer><p><a href="https://www.buymeacoffee.com/dasdom">Buy me a coffee</a></p><p><a href="/feed.rss">RSS feed</a><a> | </a><a href="https://twitter.com/dasdom">Twitter</a><a> | </a><a href="https://stackoverflow.com/users/498796/dasdom">StackOverflow</a><a> | </a><a href="https://github.com/dasdom">Github</a><a> | </a><a href="https://pragprog.com/titles/dhios/">My Book</a></p><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p></footer></body></html>
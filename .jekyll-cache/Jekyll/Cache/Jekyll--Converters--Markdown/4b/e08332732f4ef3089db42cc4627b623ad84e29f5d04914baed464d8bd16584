I"'!<p>Sometimes you have a struct/class that holds some kind of sequence and
you would like to iterate over it with <code class="highlighter-rouge">for ... in ...</code>. In
Swift the struct/class has to conform to <code class="highlighter-rouge">SequenceType</code> to
enable this iteration.</p>

<p>Let’s say you have a simple struct to hold domains:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Domains</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">names</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
  <span class="k">let</span> <span class="nv">tld</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span></code></pre></figure>

<p>To conform to <code class="highlighter-rouge">SequenceType</code> the
struct needs to implement the method:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">generate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Generator</span></code></pre></figure>

<p>and the <code class="highlighter-rouge">Generator</code> is of type
<code class="highlighter-rouge">GeneratorType</code>. Ok, let’s start with the generator.
<!--more--></p>

<p>The protocol <code class="highlighter-rouge">GeneratorType</code> looks
like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="kt">GeneratorType</span> <span class="p">{</span>
  <span class="c1">/// The type of element generated by `self`.</span>
  <span class="kd">typealias</span> <span class="kt">Element</span>
  
  <span class="c1">/// Advance to the next element and return it, or `nil` if no next</span>
  <span class="c1">/// element exists.</span>
  <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Element</span><span class="p">?</span>
<span class="p">}</span></code></pre></figure>

<p>So, the generator need to implement a method <code class="highlighter-rouge">next()</code> that returns
the next element until no element is left.</p>

<p>A simple generator for the Domains struct could look like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">DomainsGenerator</span> <span class="p">:</span> <span class="kt">GeneratorType</span> <span class="p">{</span>
    
  <span class="k">var</span> <span class="nv">domains</span><span class="p">:</span> <span class="kt">Domains</span>
  <span class="k">var</span> <span class="nv">index</span> <span class="o">=</span> <span class="mi">0</span>
    
  <span class="nf">init</span><span class="p">(</span><span class="nv">domains</span><span class="p">:</span> <span class="kt">Domains</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">domains</span> <span class="o">=</span> <span class="n">domains</span>
  <span class="p">}</span>
    
  <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">domains</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">count</span> <span class="p">?</span> <span class="s">"</span><span class="se">\(</span><span class="n">domains</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span><span class="se">)</span><span class="s">.</span><span class="se">\(</span><span class="n">domains</span><span class="o">.</span><span class="n">tld</span><span class="se">)</span><span class="s">"</span> <span class="p">:</span> <span class="kc">nil</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The method is mutating because it changes the index property.</p>

<p>The Domains struct would then conform to <code class="highlighter-rouge">SequenceType</code> like
this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">generate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">DomainsGenerator</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kt">DomainsGenerator</span><span class="p">(</span><span class="nv">domains</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>The complete example looks like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Domains</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">names</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
  <span class="k">let</span> <span class="nv">tld</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Domains</span> <span class="p">:</span> <span class="kt">SequenceType</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">generate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">DomainsGenerator</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">DomainsGenerator</span><span class="p">(</span><span class="nv">domains</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="kd">struct</span> <span class="kt">DomainsGenerator</span> <span class="p">:</span> <span class="kt">GeneratorType</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="nv">domains</span><span class="p">:</span> <span class="kt">Domains</span>
    <span class="k">var</span> <span class="nv">index</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">domains</span><span class="p">:</span> <span class="kt">Domains</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="o">.</span><span class="n">domains</span> <span class="o">=</span> <span class="n">domains</span>
    <span class="p">}</span>
    
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">domains</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">count</span> <span class="p">?</span> <span class="s">"(domains.names[index++]).(domains.tld)"</span> <span class="p">:</span> <span class="kc">nil</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">domains</span> <span class="o">=</span> <span class="kt">Domains</span><span class="p">(</span><span class="nv">names</span><span class="p">:</span> <span class="p">[</span><span class="s">"swiftandpainless"</span><span class="p">,</span><span class="s">"duckduckgo"</span><span class="p">,</span><span class="s">"apple"</span><span class="p">,</span><span class="s">"github"</span><span class="p">],</span> <span class="nv">tld</span><span class="p">:</span> <span class="s">"com"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">domain</span> <span class="k">in</span> <span class="n">domains</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

:ET
I"ó<p>This post is part of a series in which we build a geofence App.</p>

<p>To be able to write tests, we need a test target. If you donâ€™t have a test target already, you can add one in the target list:</p>

<p style="text-align: center;"><img src="http://localhost:4000/assets/2018-09-24/01.png" alt="Login screen" /></p>

<p>Chose the iOS Unit Testing Bundle. Per default, Xcode adds a test case to the test target. A test case is a class containing several different tests for one specific aspect of the app. The test case added by Xcode is not really useful because it has a strange name; the name of the target with a postfix â€˜Testsâ€™. If weâ€™d take that name serious, we would put into that test case all tests for the app. That would be to messy. We need a new test case.</p>

<p>Select the test case and add a new file. Chose the Unit Test Case Class template.</p>

<p style="text-align: center;"><img src="http://localhost:4000/assets/2018-09-24/02.png" alt="Login screen" /></p>

<p>I call the new test case <code class="highlighter-rouge">AddGeofenceTests</code>. Iâ€™m not sure which tests will go here, so when the name doesnâ€™t match the contents anymore, we can change the name. For now itâ€™s enough to get us started.</p>

<p>The template provided by Xcode already has two tests. We donâ€™t need those, so they can be deleted.</p>

<h3 id="availability-of-location-services">Availability of location services</h3>
<p>But what do we need to test? <a href="https://developer.apple.com/documentation/corelocation/determining_the_availability_of_location_services">In the documentation of the Core Location framework</a> there is this sentence:</p>

<blockquote>
  <p>Before using any specific location service, check the availability of that service using the methods of your CLLocationManager object.</p>
</blockquote>

<p>And there is one method that seems to fit our use case:</p>

<blockquote>
  <p><strong><code class="highlighter-rouge">locationServicesEnabled()</code></strong> <br />
Tells whether you can get the geographic coordinate for the userâ€™s current location.</p>
</blockquote>

<p>So we add the test method:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">test_viewLoading_calls_locationServicesEnabled</span><span class="p">()</span> <span class="p">{</span>
    
<span class="p">}</span></code></pre></figure>

<p>Test methods in XCTest (the testing framework we are using here) need to start with the word test. Otherwise the test runner canâ€™t find them. The rest of the name should describe what the test is doing. You should be able to guess what the test is doing several months after you have written it. In test methods I prefer snake_case but feel free to chose a naming scheme that better fits you taste.</p>

<p>This is already a valid test even though it has no body. Run the tests (<strong>Product &gt; Test</strong>) and see what happens.</p>

<p style="text-align: center;"><img src="http://localhost:4000/assets/2018-09-24/03.png" alt="Login screen" /></p>

<p>After the tests have finished, Xcode shows a checkmark next to the test method. This means the test passed. So an empty test is always green (i.e. it passes). Keep that in mind. Thatâ€™s important because if you forget to run the tests before you have written any code, you cannot be sure that the test actually tests something.</p>

<h3 id="mocking">Mocking</h3>
<p>To figure out whether <code class="highlighter-rouge">locationServicesEnabled()</code> is called we need to inject a placeholder object into the production code that is able to register calls to this method. This process is called <em>mocking</em>. And it works like this:</p>

<ul>
  <li>Add code that allows to change dependencies in the code.</li>
  <li>Create a mock object that can be injected into the code and inject it.</li>
  <li>Call the method youâ€™d like to test.</li>
  <li>Assert that the method you expected to be called is actually called.</li>
</ul>

<p>Donâ€™t worry, this sounds more complicated than it is. So letâ€™s see it in action.</p>

<p>First we need a class that enables the user to add a geofence. For now weâ€™ll put that code into the view controller that shows the user interface. Later on we might find a better place for that code.</p>

<p>In Test-Driven Development you always start with a failing test (and compilation errors count as a failing test). In the test method <code class="highlighter-rouge">test_viewLoading_calls_locationServicesEnabled()</code> add the following code:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">sut</span> <span class="o">=</span> <span class="kt">AddGeofenceViewController</span><span class="p">()</span></code></pre></figure>

<p>The compiler complains</p>
<blockquote>
  <p>Use of unresolved identifier â€˜AddGeofenceViewControllerâ€™</p>
</blockquote>

<p>Yeah sure, there is no class with that name in the project. So we have our first failing test. Letâ€™s make the test pass. To achieve that, we need to add a class with that name. Add a subclass of <code class="highlighter-rouge">UIViewController</code> with the name <code class="highlighter-rouge">AddGeofenceViewController</code> to the main target. Remove the template code within the class such that it looks like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">class</span> <span class="kt">AddGeofenceViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

<span class="p">}</span></code></pre></figure>

<p>Head back to the test and import the main target into the test case:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">import</span> <span class="kt">Fency</span></code></pre></figure>

<p>Uh, it still does not compile. The reason is that the default access level in Swift is internal. This means our new class is only accessible from within the main target. To make it accessible from the test target, add the keyword <code class="highlighter-rouge">@testable</code> to the import statement:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">@testable</span> <span class="kd">import</span> <span class="kt">Fency</span></code></pre></figure>

<p>This is a neat feature of Swift. But you should only use it in tests. And unfortunately it does not import private classes, properties and methods. Those arenâ€™t testable in Swift.</p>

<p>Following the bullet points, we first need to add code that allows to change dependencies in the code. Our class will use <code class="highlighter-rouge">CLLocationManager</code> to figure out if the device is able to locate itself using location services. In the test, we want to inject into the code an object controlled by the tests. This object will register when <code class="highlighter-rouge">locationServicesEnabled()</code> is called.</p>
:ET
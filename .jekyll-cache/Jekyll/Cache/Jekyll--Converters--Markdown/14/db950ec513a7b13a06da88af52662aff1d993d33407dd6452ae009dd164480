I"<p>This post is part of a series in which we build a geofence App.</p>

<p>In the app we are going to build, the user will be able to add geofences. To understand what we need to build to make that possible, letâ€™s see what a geofence looks like. Geofences are added using the following method of <code class="highlighter-rouge">CLLocationManager</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">stopMonitoring</span><span class="p">(</span><span class="k">for</span> <span class="nv">region</span><span class="p">:</span> <span class="kt">CLRegion</span><span class="p">)</span></code></pre></figure>

<p><code class="highlighter-rouge">CLLocationManger</code> is a class in the Core Location framework.</p>

<p>This means, we define a geofence as a <code class="highlighter-rouge">CLRegion</code>. But <a href="https://developer.apple.com/documentation/corelocation/clregion">the documentation from Apple states</a> that <code class="highlighter-rouge">CLRegion</code> is an abstract class:</p>

<blockquote>
  <p>In iOS, this class is abstract and you do not create instances of this class directly; instead, you instantiate subclasses that define specific types of regions.</p>
</blockquote>

<p>One of the subclasses provided by Apple is <code class="highlighter-rouge">CLCircularRegion</code> with the initialiser:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="nf">init</span><span class="p">(</span><span class="nv">center</span><span class="p">:</span> <span class="kt">CLLocationCoordinate2D</span><span class="p">,</span> 
     <span class="nv">radius</span><span class="p">:</span> <span class="kt">CLLocationDistance</span><span class="p">,</span> 
     <span class="nv">identifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span></code></pre></figure>

<p>So here is finally the answer. To setup a geofence we need a coordinate, a radius and an identifier. For the identifier, we will create a unique id. The radius will be a fixed value, letâ€™s say 20 meters. Later it would be good to let the user decide how big the radius should be. But for the start itâ€™s enough to have a fixed value.</p>

<p>For the coordinate, we need to figure out the location of the device the app is running on. This can be done again using an instance of <code class="highlighter-rouge">CLLocationManager</code>. If you have used an iOS device before (and as youâ€™re reading this, Iâ€™m sure you have) you definitely have seen the authorisation request whether the app is allowed to get the location of the device. This is what we have to do in our app.</p>

<p>In the next post in this series we are going to write our first test to guide the development.</p>

<p>You might ask why we write the test before there is anything to test. This is called Test-Driven Development (TDD) and itâ€™s a good idea for several reasons. Go, look up the term TDD in the internet.</p>

<p>We are using it here because it guides the development and the thought process. By starting with a failing test (it fails because there is nothing that could make the test pass), we make sure that the test does not always pass. It could be that we have a test that passes, because we made a mistake. We could be falsely confident that our app works because all the tests pass.</p>

<p>Before we continue writing the geofence app weâ€™ll need to learn the basics of TDD.</p>

<p>If you have any feedback ping me on <a href="https://twitter.com/dasdom">Twitter</a>.</p>
:ET
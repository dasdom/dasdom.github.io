I"¦/<p>As you all know <code class="highlighter-rouge">NSCoding</code> doesnâ€™t
work with Swift structs. <code class="highlighter-rouge">NSCoding</code> only works
for classes inheriting from <code class="highlighter-rouge">NSObject</code>. But the
next (or current) big thing are structs. Value types all the way. So we
need a way to archive and unarchive instances of structs.</p>

<p><a href="https://twitter.com/redqueencoder">Janie</a>
<a href="http://redqueencoder.com/property-lists-and-user-defaults-in-swift/">wrote</a>
about how they solved it at Sonoplot where she works.</p>

<p><strong>Tl;dr</strong>: They define a protocol that has two methods: one for getting
an <code class="highlighter-rouge">NSDictionary</code> out of
a struct and one for initializing the struct with an <code class="highlighter-rouge">NSDictionary</code>. The
<code class="highlighter-rouge">NSDictionary</code> is then serialized using <code class="highlighter-rouge">NSKeyedArchiver</code>. The
beauty of this approach is that each struct conforming to that protocol
can be serialized.</p>

<p>I came up with an other approach. It just popped up in my mind. And even
after experimenting with it and implementing a little toy project Iâ€™m
still not sure if this is a good idea. Itâ€™s definitely not as beautiful
as the approach mentioned above. I put it here to let you decide.
<!--more--></p>

<p>Letâ€™s say we have a person struct:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">let</span> <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span></code></pre></figure>

<p>So we canâ€™t make this conforming to <code class="highlighter-rouge">NSCoding</code> but we can
add a class <strong>within</strong> the <strong>Person</strong> struct that conforms to <code class="highlighter-rouge">NSCoding</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="kd">class</span> <span class="kt">HelperClass</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">NSCoding</span> <span class="p">{</span>
    
    <span class="k">var</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">Person</span><span class="p">?</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">Person</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="o">.</span><span class="n">person</span> <span class="o">=</span> <span class="n">person</span>
      <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">class</span> <span class="kd">func</span> <span class="nf">path</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">documentsPath</span> <span class="o">=</span> <span class="kt">NSSearchPathForDirectoriesInDomains</span><span class="p">(</span><span class="kt">NSSearchPathDirectory</span><span class="o">.</span><span class="kt">DocumentDirectory</span><span class="p">,</span> <span class="kt">NSSearchPathDomainMask</span><span class="o">.</span><span class="kt">UserDomainMask</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span><span class="o">.</span><span class="n">first</span>
      <span class="k">let</span> <span class="nv">path</span> <span class="o">=</span> <span class="n">documentsPath</span><span class="p">?</span><span class="o">.</span><span class="nf">stringByAppendingString</span><span class="p">(</span><span class="s">"/Person"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">path</span><span class="o">!</span>
    <span class="p">}</span>
    
    <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="n">coder</span> <span class="nv">aDecoder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">guard</span> <span class="k">let</span> <span class="nv">firstName</span> <span class="o">=</span> <span class="n">aDecoder</span><span class="o">.</span><span class="nf">decodeObjectForKey</span><span class="p">(</span><span class="s">"firstName"</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">String</span> <span class="k">else</span> <span class="p">{</span> <span class="n">person</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span> <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">();</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
      <span class="k">guard</span> <span class="k">let</span> <span class="nv">laseName</span> <span class="o">=</span> <span class="n">aDecoder</span><span class="o">.</span><span class="nf">decodeObjectForKey</span><span class="p">(</span><span class="s">"lastName"</span><span class="p">)</span> <span class="k">as?</span> <span class="kt">String</span> <span class="k">else</span> <span class="p">{</span> <span class="n">person</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span> <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">();</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
      
      <span class="n">person</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="n">firstName</span><span class="p">,</span> <span class="nv">lastName</span><span class="p">:</span> <span class="n">laseName</span><span class="p">)</span>
      
      <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">encodeWithCoder</span><span class="p">(</span><span class="nv">aCoder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">aCoder</span><span class="o">.</span><span class="nf">encodeObject</span><span class="p">(</span><span class="n">person</span><span class="o">!.</span><span class="n">firstName</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="s">"firstName"</span><span class="p">)</span>
      <span class="n">aCoder</span><span class="o">.</span><span class="nf">encodeObject</span><span class="p">(</span><span class="n">person</span><span class="o">!.</span><span class="n">lastName</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="s">"lastName"</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>So, what is happening here. We have just added a class within the
<strong>Person</strong> struct that conforms to <code class="highlighter-rouge">NSCoding</code> which means
it implements the methods <code class="highlighter-rouge">init?(coder aDecoder: NSCoder)</code> and 
<code class="highlighter-rouge">encodeWithCoder(aCoder: NSCoder)</code>. The class has a property of type 
<code class="highlighter-rouge">Person</code> and in <code class="highlighter-rouge">encodeWithCoder(aCoder: NSCoder)</code> 
it writes the values of the properties of the person
instance to the coder and in <code class="highlighter-rouge">init?(coder aDecoder: NSCoder)</code> it 
reads those values again from the decoder and creates
a new person instance.</p>

<p>Whatâ€™s left is to add encoding and decoding methods to the <strong>Person</strong>
struct:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">let</span> <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span>
  
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">personClassObject</span> <span class="o">=</span> <span class="kt">HelperClass</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="n">person</span><span class="p">)</span>
    
    <span class="kt">NSKeyedArchiver</span><span class="o">.</span><span class="nf">archiveRootObject</span><span class="p">(</span><span class="n">personClassObject</span><span class="p">,</span> <span class="nv">toFile</span><span class="p">:</span> <span class="kt">HelperClass</span><span class="o">.</span><span class="nf">path</span><span class="p">())</span>
  <span class="p">}</span>
  
  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Person</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">personClassObject</span> <span class="o">=</span> <span class="kt">NSKeyedUnarchiver</span><span class="o">.</span><span class="nf">unarchiveObjectWithFile</span><span class="p">(</span><span class="kt">HelperClass</span><span class="o">.</span><span class="nf">path</span><span class="p">())</span> <span class="k">as?</span> <span class="kt">HelperClass</span>

    <span class="k">return</span> <span class="n">personClassObject</span><span class="p">?</span><span class="o">.</span><span class="n">person</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>With this code we create a <strong>HelperClass</strong> object to make the archiving
and unarchiving.</p>

<p>The struct is used like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">me</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="s">"Dominik"</span><span class="p">,</span> <span class="nv">lastName</span><span class="p">:</span> <span class="s">"Hauser"</span><span class="p">)</span>
    
<span class="kt">Person</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">me</span><span class="p">)</span>
    
<span class="k">let</span> <span class="nv">myClone</span> <span class="o">=</span> <span class="kt">Person</span><span class="o">.</span><span class="nf">decode</span><span class="p">()</span>
    
<span class="n">firstNameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">myClone</span><span class="p">?</span><span class="o">.</span><span class="n">firstName</span>
<span class="n">lastNameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">myClone</span><span class="p">?</span><span class="o">.</span><span class="n">lastName</span></code></pre></figure>

<p>You can find the code for this experiment on
<a href="https://github.com/dasdom/EncodeExperiments">github</a>.</p>

<p>If you enjoyed this post, then make sure you subscribe to my
<a href="http://swiftandpainless.com/feed">feed</a>.</p>
:ET
I"–'<p>This post is part of a series in which we build a geofencing App.</p>

<p>In the app we are going to build, the user will be able to add geofences. To understand what we need to build to make that possible, letâ€™s see what a geofence looks like. Geofences are added using the following method of <code class="highlighter-rouge">CLLocationManager</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">stopMonitoring</span><span class="p">(</span><span class="k">for</span> <span class="nv">region</span><span class="p">:</span> <span class="kt">CLRegion</span><span class="p">)</span></code></pre></figure>

<p><code class="highlighter-rouge">CLLocationManger</code> is a class in the Core Location framework.</p>

<p>This means, we define a geofence as a <code class="highlighter-rouge">CLRegion</code>. But <a href="https://developer.apple.com/documentation/corelocation/clregion">the documentation from Apple states</a> that <code class="highlighter-rouge">CLRegion</code> is an abstract class:</p>

<blockquote>
  <p>In iOS, this class is abstract and you do not create instances of this class directly; instead, you instantiate subclasses that define specific types of regions.</p>
</blockquote>

<p>One of the subclasses provided by Apple is <code class="highlighter-rouge">CLCircularRegion</code> with the initialiser:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="nf">init</span><span class="p">(</span><span class="nv">center</span><span class="p">:</span> <span class="kt">CLLocationCoordinate2D</span><span class="p">,</span> 
     <span class="nv">radius</span><span class="p">:</span> <span class="kt">CLLocationDistance</span><span class="p">,</span> 
     <span class="nv">identifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span></code></pre></figure>

<p>So here is finally the answer. To setup a geofence we need a coordinate, a radius and an identifier. For the identifier, we will create a unique id. The radius will be a fixed value, letâ€™s say 20 meters. Later it would be good to let the user decide how big the radius should be. But for the start itâ€™s enough to have a fixed value.</p>

<p>For the coordinate, we need to figure out the location of the device the app is running on. This can be done again using an instance of <code class="highlighter-rouge">CLLocationManager</code>. If you have used an iOS device before (and as youâ€™re reading this, Iâ€™m sure you have) you definitely have seen the authorisation request whether the app is allowed to get the location of the device. This is what we have to do in our app.</p>

<p>In the next post we are going to write our first test to guide the development.</p>

<p><em>You might ask why we write the test before there is anything to test. This is called Test-Driven Development (TDD) and itâ€™s a good idea for several reasons. Go, look up the term TDD in the internet. <br />
We are using it here because it guides the development and the thought process. By starting with a failing test (it fails because there is nothing that could make the test pass), we make sure that the test does not always pass. It could be that we have a test that passes, because we made a mistake. We could be falsely confident that our app works because all the tests pass. <br />
I will give a short introduction into TDD in the next part. For now, trust me that this is reasonable.</em></p>

<p>To be able to write tests, we need a test target. If you donâ€™t have a test target already, you can add one in the target list:</p>

<p style="text-align: center;"><img src="http://localhost:4000/assets/2018-09-24/01.png" alt="Login screen" /></p>

<p>Chose the iOS Unit Testing Bundle. Per default, Xcode adds a test case to the test target. A test case is a class containing several different tests for one specific aspect of the app. The test case added by Xcode is not really useful because it has a strange name; the name of the target with a postfix â€˜Testsâ€™. If weâ€™d take that name serious, we would put into that test case all tests for the app. That would be to messy. We need a new test case.</p>

<p>Select the test case and add a new file. Chose the Unit Test Case Class template.</p>

<p style="text-align: center;"><img src="http://localhost:4000/assets/2018-09-24/02.png" alt="Login screen" /></p>

<p>I call the new test case <code class="highlighter-rouge">AddGeofenceTests</code>. Iâ€™m not sure which tests will go here, so when the name doesnâ€™t match the contents anymore, we can change the name. For now itâ€™s enough to get us started.</p>

<p>The template provided by Xcode already has two tests. We donâ€™t need those, so they can be deleted.</p>

<h3 id="availability-of-location-services">Availability of location services</h3>
<p>But what do we need to test? <a href="https://developer.apple.com/documentation/corelocation/determining_the_availability_of_location_services">In the documentation of the Core Location framework</a> there is this sentence:</p>

<blockquote>
  <p>Before using any specific location service, check the availability of that service using the methods of your CLLocationManager object.</p>
</blockquote>

<p>And there is one method that seems to fit our use case:</p>

<blockquote>
  <p><strong><code class="highlighter-rouge">locationServicesEnabled()</code></strong> <br />
Tells whether you can get the geographic coordinate for the userâ€™s current location.</p>
</blockquote>

<p>So we add the test method:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">test_viewLoading_calls_locationServicesEnabled</span><span class="p">()</span> <span class="p">{</span>
    
<span class="p">}</span></code></pre></figure>

<p>Test methods in XCTest (the testing framework we are using here) need to start with the word test. Otherwise the test runner canâ€™t find them. The rest of the name should describe what the test is doing. You should be able to guess what the test is doing several months after you have written it. In test methods I prefer snake_case but feel free to chose a naming scheme that better fits you taste.</p>

<p>This is already a valid test even though it has no body. Run the tests (<strong>Product &gt; Test</strong>) and see what happens.</p>

<p style="text-align: center;"><img src="http://localhost:4000/assets/2018-09-24/03.png" alt="Login screen" /></p>

<p>After the tests have finished, Xcode shows a checkmark next to the test method. This means the test passed. So an empty test is always green (i.e. it passes). Keep that in mind. Thatâ€™s important because if you forget to run the tests before you have written any code, you cannot be sure that the test actually tests something.</p>

<p>To figure out whether <code class="highlighter-rouge">locationServicesEnabled()</code> is called we need to inject a placeholder object into the production code that is able to register calls to this method. This process is called <em>mocking</em>. And it works like this:</p>

<ul>
  <li>Add code that allows to change dependencies in the code.</li>
  <li>Create a mock object that can be injected into the code and inject it.</li>
  <li>Call the method youâ€™d like to test.</li>
  <li>Assert that the method you expected to be called is actually called.</li>
</ul>

<p>Donâ€™t worry, this sounds more complicated than it is. So letâ€™s see it in action.</p>

<p>First we need a class that enables the user to add a geofence. For now weâ€™ll put that code into the view controller that shows the user interface. Later on we might find a better place for that code.</p>

<p>In Test-Driven Development you always start with a failing test (and compilation errors count as a failing test). In the test method <code class="highlighter-rouge">test_viewLoading_calls_locationServicesEnabled()</code> add the following code:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">sut</span> <span class="o">=</span> <span class="kt">AddGeofenceViewController</span><span class="p">()</span></code></pre></figure>

<p>The compiler complains</p>
<blockquote>
  <p>Use of unresolved identifier â€˜AddGeofenceViewControllerâ€™</p>
</blockquote>

<p>Yeah sure, there is no class with that name in the project. So we have our first failing test. Letâ€™s make the test pass. To achieve that, we need to add a class with that name. Add a subclass of <code class="highlighter-rouge">UIViewController</code> with the name <code class="highlighter-rouge">AddGeofenceViewController</code> to the main target. Remove the template code within the class such that it looks like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">class</span> <span class="kt">AddGeofenceViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

<span class="p">}</span></code></pre></figure>

<p>Head back to the test and import the main target into the test case:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">import</span> <span class="kt">Fency</span></code></pre></figure>

<p>Uh, it still does not compile. The reason is that the default access level in Swift is internal. This means our new class is only accessible from within the main target. To make it accessible from the test target, add the keyword <code class="highlighter-rouge">@testable</code> to the import statement:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">@testable</span> <span class="kd">import</span> <span class="kt">Fency</span></code></pre></figure>

<p>This is a neat feature of Swift. But you should only use it in tests. And unfortunately it does not import private classes, properties and methods. Those arenâ€™t testable in Swift.</p>
:ET
I"<p>Clearly we all write unit test to test our code, aren't we. ;)<br />
Here is how I test my networking code.</p>
<p>To test networking code I use the open source framework [OHHTTPStubs](https://github.com/AliSoftware/OHHTTPStubs) by [AliSoftware](https://github.com/AliSoftware). I've added it to my project with [cocoapods](http://cocoapods.org). Search the web how to get cocoapods to work with a test target.</p>
<p>In Xcode go to `File &gt; New &gt; File...` and select `Objective-C test case class`. Name the class `DataFetcher`, click next and add it to the Test Target.</p>
<p>Import the header files `OHHTTPStubs.h` and `DataFetcher.h` into the test case class. We need a property of the class we would like to test. In the case of this example this is a `DataFetcher`. As we are testing asynchronous requests we also need a `BOOL` property to indicate if the API request is done.</p>
<p>[code language="objc"]<br />
#import &lt;XCTest/XCTest.h&gt;<br />
#import &quot;OHHTTPStubs.h&quot;<br />
#import &quot;DataFetcher.h&quot;</p>
<p>@interface DataFetcherTests : XCTestCase<br />
@property (nonatomic, strong) DataFetcher *dataFetcher;<br />
@property (nonatomic, assign) BOOL done;<br />
@end<br />
[/code]</p>
<p>Now we edit the `setUp` and the `tearDown` methods to look like this:</p>
<p>[code language="objc"]<br />
- (void)setUp {<br />
    [super setUp];<br />
    self.dataFetcher = [[DataFetcher alloc] init];<br />
    self.done = NO;<br />
}</p>
<p>- (void)tearDown{<br />
    self.dataFetcher = nil;<br />
    [OHHTTPStubs removeAllStubs];<br />
    [super tearDown];<br />
}<br />
[/code]</p>
<p>We have to add a method which helps us to wait for the completion of the asynchronous requests.</p>
<p>[code language="objc"]<br />
- (BOOL)waitForCompletion:(NSTimeInterval)timeoutSecs {<br />
    NSDate *timeoutDate = [NSDate dateWithTimeIntervalSinceNow:timeoutSecs];</p>
<p>    do {<br />
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:timeoutDate];<br />
        if([timeoutDate timeIntervalSinceNow] &lt; 0.0)<br />
            break;<br />
    } while (!self.done);</p>
<p>    return self.done;<br />
}<br />
[/code]<br />
I've copied the code from the [Infinite Loop Blog](http://www.infinite-loop.dk/blog/2011/04/unittesting-asynchronous-network-access/).</p>
<p>Let's write the first test. This test simply tests if the expected API endpoint is called.</p>
<p>[code language="objc"]<br />
- (void)testThatFetchGlobalStreamCallsAPI {<br />
    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {<br />
        NSLog(@&quot;request.URL.absoluteString: %@&quot;, request.URL.absoluteString);<br />
        BOOL adnAPICall = [request.URL.host isEqualToString:@&quot;alpha-api.app.net&quot;];<br />
        if (adnAPICall) {<br />
            XCTAssertEqualObjects(request.URL.absoluteString, @&quot;https://alpha-api.app.net/stream/0/posts/stream/global&quot;);<br />
        }<br />
        return adnAPICall;<br />
    } withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {<br />
        return nil;<br />
    }];</p>
<p>    typeof(self) __weak weakSelf = self;<br />
    [self.dataFetcher fetchGlobalStreamWithCompletion:^(NSArray *globalPostArray, NSError *error) {<br />
        typeof(self) __strong strongSelf = weakSelf;<br />
        strongSelf.done = YES;<br />
    }];</p>
<p>    XCTAssertTrue([self waitForCompletion:5.0f], @&quot;Didn't complete in expected time.&quot;);<br />
}<br />
[/code]</p>
<p>Done! To check whether we really testing our code, change `fetchGlobalStreamWithCompletion:` to use another API endpoint and run the test (Cmd u). It should fail. Change the test back to the expected API endpoint and run the test again. Now the test should succeed.</p>
<p>Ok, our code calls the expected API endpoint. What about the response? Does our code proceed the response in a way we would expect? Let's add a test:<br />
First we need a file with a response which looks like what we expect. Open the Terminal, navigate to the test folder of your project and put into the prompt:</p>
<p>[code]<br />
echo '{&quot;meta&quot;:{&quot;min_id&quot;:&quot;0&quot;,&quot;code&quot;:200,&quot;max_id&quot;:&quot;0&quot;,&quot;more&quot;:true},&quot;data&quot;:[{&quot;text&quot;:&quot;This is a test response.&quot;}]}' &gt; globalStreamResponse.json<br />
[/code]</p>
<p>Add the file `globalStreamResponse.json` to the test target. The response from the real API is way more complicated. But we only want to test here whether the response is correctly put into the array and passed to the block. (Another test would be whether a more realistic API response is correctly transformed into objects.)</p>
<p>[code language="objc" highlight="10,12,19,24,25,27"]<br />
- (void)testThatFetchGlobalStreamReturnsExpectedResponse {<br />
    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {<br />
        NSLog(@&quot;request.URL.absoluteString: %@&quot;, request.URL.absoluteString);<br />
        BOOL adnAPICall = [request.URL.host isEqualToString:@&quot;alpha-api.app.net&quot;];<br />
        if (adnAPICall) {<br />
            XCTAssertEqualObjects(request.URL.absoluteString, @&quot;https://alpha-api.app.net/stream/0/posts/stream/global&quot;);<br />
        }<br />
        return adnAPICall;<br />
    } withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {<br />
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@&quot;globalStreamResponse&quot; ofType:@&quot;json&quot;];<br />
        NSLog(@&quot;path: %@&quot;, path);<br />
        return [OHHTTPStubsResponse responseWithFileAtPath:path statusCode:200 headers:@{@&quot;Content-Type&quot;:@&quot;text/json&quot;}];<br />
    }];</p>
<p>    typeof(self) __weak weakSelf = self;<br />
    [self.dataFetcher fetchGlobalWithCompletion:^(NSArray *globalPostArray, NSError *error) {<br />
        typeof(self) __strong strongSelf = weakSelf;</p>
<p>        XCTAssertEqual([globalPostArray count], 1);</p>
<p>        NSDictionary *expecedResponse = @{@&quot;text&quot; : @&quot;This is an easy test response.&quot;};<br />
        id firstResponseElement = [globalPostArray firstObject];</p>
<p>        XCTAssertTrue([firstResponseElement isKindOfClass:[NSDictionary class]]);<br />
        XCTAssertEqual([(NSDictionary*)firstResponseElement count], [expecedResponse count]);<br />
        for (NSString *keyStrings in expecedResponse) {<br />
            XCTAssertEqualObjects(expecedResponse[keyStrings], firstResponseElement[keyStrings]);<br />
        }<br />
        strongSelf.done = YES;<br />
    }];</p>
<p>    XCTAssertTrue([self waitForCompletion:5.0f], @&quot;Didn't complete in expected time.&quot;);<br />
}<br />
[/code]</p>
<p>In line 10 the file we created is loaded and this is used to create the response in line 12. The tests are in the lines 19, 24, 25 and 27. </p>
<p>In line 19 we are testing the number of the elements in the returned array. </p>
<p>In line 24 we test whether the first element in the array is of kind `NSDictionary`. This isn't really needed because if it wouldn't be an `NSDictionary` one of the later tests would fail. But the test doesn't hurt and it reminds us about what we are expecting.</p>
<p>The next test (line 25) tests the number of elements in the dictionary.</p>
<p>And finally we test all the elements in the dictionary (line 27). It's kind of worthless to have a loop here. But if we decide to change the test response to have more elements (for example we could use a real response from the App.net API) we would not have to change the test. Remove the loop if it bothers you. </p>
<p>This is how I test my networking code. </p>
<p>You can find the project on [github](https://github.com/dasdom/SimpleTableView). If you have any comments, feel free to contact me at App.net [@dasdom](https://alpha.app.net/dasdom) or at Twitter [@dasdom](https://twitter.com/dasdom).</p>
:ET